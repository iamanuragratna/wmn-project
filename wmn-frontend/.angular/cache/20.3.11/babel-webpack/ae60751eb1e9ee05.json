{"ast":null,"code":"import { Client } from '@stomp/stompjs';\nimport * as SockJSRaw from 'sockjs-client';\nimport { Subject, BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nconst SockJS = SockJSRaw && SockJSRaw.default ? SockJSRaw.default : SockJSRaw;\n/**\n * Robust STOMP over SockJS service with verbose logging for debugging.\n *\n * - Connects to the broker endpoint (use your backend SockJS endpoint)\n * - Subscribes to /topic/telemetry\n * - Emits parsed messages on messages$\n * - Emits raw bus messages on rawMessages$ for debugging\n */\nexport let WebsocketService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class WebsocketService {\n    constructor() {\n      this.url = 'http://localhost:8085/ws/telemetry'; // backend SockJS endpoint\n      this.messages$ = new Subject(); // parsed {type, payload}\n      this.rawMessages$ = new Subject(); // raw message body (for debugging)\n      this.status$ = new BehaviorSubject('DISCONNECTED');\n    }\n    connect() {\n      console.log('[WS] connect called, current client:', !!this.client);\n      if (this.client && this.client.connected) {\n        console.log('[WS] already connected, skipping.');\n        return;\n      }\n      this.status$.next('CONNECTING');\n      // create SockJS factory\n      const sockFactory = () => {\n        try {\n          const s = new SockJS(this.url);\n          console.log('[WS] created SockJS instance', s);\n          return s;\n        } catch (err) {\n          console.error('[WS] SockJS creation failed', err);\n          throw err;\n        }\n      };\n      // create STOMP client\n      this.client = new Client({\n        brokerURL: undefined,\n        // required when using webSocketFactory\n        webSocketFactory: sockFactory,\n        reconnectDelay: 5000,\n        heartbeatIncoming: 0,\n        heartbeatOutgoing: 10000,\n        debug: str => {\n          // keep this verbose during debugging\n          console.log('[STOMP]', str);\n        },\n        onConnect: frame => {\n          console.log('[STOMP] onConnect', frame.headers);\n          this.status$.next('CONNECTED');\n          // subscribe to telemetry topic\n          try {\n            // unsubscribe if existing\n            if (this.subscription) {\n              try {\n                this.subscription.unsubscribe();\n              } catch (e) {/*noop*/}\n              this.subscription = undefined;\n            }\n            this.subscription = this.client.subscribe('/topic/telemetry', message => {\n              try {\n                const body = message.body || '';\n                console.log('[STOMP] raw message received (length=' + body.length + ')');\n                this.rawMessages$.next(body);\n                // Try to parse JSON. If already a JSON text with 'type'/'payload' use it directly.\n                let parsed;\n                try {\n                  parsed = JSON.parse(body);\n                } catch (e) {\n                  console.warn('[STOMP] JSON parse failed, wrapping raw body', e);\n                  parsed = {\n                    type: 'raw',\n                    payload: body\n                  };\n                }\n                // If message is already {type,payload} emit as-is. Otherwise attempt to normalize.\n                if (parsed && parsed.type && parsed.payload) {\n                  this.messages$.next(parsed);\n                } else {\n                  // heuristic: detect telemetry feature objects and set type accordingly\n                  const t = parsed.type || (parsed.avgChannelBusyPercent || parsed.avgChannelBusyPercent === 0 ? 'feature_update' : parsed.forecastBusyPercent || parsed.forecastBusyPercent === 0 ? 'forecast_update' : parsed.nodeId ? 'feature_update' : 'unknown');\n                  this.messages$.next({\n                    type: t,\n                    payload: parsed\n                  });\n                }\n              } catch (err) {\n                console.error('[STOMP] subscription handler error', err);\n              }\n            });\n            console.log('[STOMP] subscribed to /topic/telemetry');\n          } catch (err) {\n            console.error('[STOMP] subscribe failed', err);\n          }\n        },\n        onStompError: frame => {\n          console.error('[STOMP] stomp error', frame);\n          this.status$.next('ERROR');\n        },\n        onWebSocketClose: ev => {\n          console.warn('[STOMP] websocket closed', ev);\n          this.status$.next('DISCONNECTED');\n        },\n        onWebSocketError: ev => {\n          console.error('[STOMP] websocket error', ev);\n          this.status$.next('ERROR');\n        }\n      });\n      // activate the client (starts the connection)\n      try {\n        this.client.activate();\n        console.log('[STOMP] client.activate() called');\n      } catch (err) {\n        console.error('[STOMP] client.activate() error', err);\n        this.status$.next('ERROR');\n      }\n    }\n    disconnect() {\n      console.log('[WS] disconnect called');\n      try {\n        if (this.subscription) {\n          try {\n            this.subscription.unsubscribe();\n          } catch (e) {/*noop*/}\n          this.subscription = undefined;\n        }\n        if (this.client) {\n          this.client.deactivate();\n        }\n        this.status$.next('DISCONNECTED');\n      } catch (err) {\n        console.error('[WS] disconnect error', err);\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function WebsocketService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || WebsocketService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: WebsocketService,\n      factory: WebsocketService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return WebsocketService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}