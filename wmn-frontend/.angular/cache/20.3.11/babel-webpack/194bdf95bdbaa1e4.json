{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"./services/websocket.service\";\nimport * as i2 from \"@angular/common/http\";\nfunction AppComponent_div_35_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵdomElementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵdomElementEnd();\n  }\n  if (rf & 2) {\n    const l_r1 = ctx.$implicit;\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(l_r1);\n  }\n}\nexport let AppComponent = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class AppComponent {\n    constructor(ws, http) {\n      this.ws = ws;\n      this.http = http;\n      // summaries / stores used by many child components\n      this.nodes = {};\n      this.telemetry = {};\n      this.forecasts = {};\n      this.plans = [];\n      this.commands = [];\n      this.logs = [];\n      // expose Object for templates that reference it\n      this.Object = Object;\n      // caps to prevent unbounded growth\n      this.TELEMETRY_MAX_PER_NODE = 500;\n      this.PLANS_MAX = 200;\n      this.COMMANDS_MAX = 200;\n      this.LOGS_MAX = 300;\n    }\n    ngOnInit() {\n      // subscribe to parsed messages stream produced by your WebsocketService\n      this.sub = this.ws.messages$.subscribe(msg => {\n        try {\n          const {\n            type,\n            payload\n          } = msg;\n          if (!type || !payload) {\n            console.warn('[AppComponent] malformed message', msg);\n            return;\n          }\n          // --- FEATURE / TELEMETRY updates ---\n          if (type === 'feature_update') {\n            const nodeId = payload.nodeId;\n            if (!nodeId) return;\n            // build normalized sample\n            const sample = {\n              ts: payload.windowEnd || new Date().toISOString(),\n              busy: payload.avgChannelBusyPercent ?? payload.busy ?? null,\n              rssi: payload.avgRssi ?? payload.rssi ?? null,\n              txBytes: payload.sumTxBytes ?? payload.txBytes ?? null\n            };\n            // create new array reference for this node's telemetry (append + cap)\n            const prevArr = this.telemetry[nodeId] || [];\n            let newArr = [...prevArr, sample];\n            if (newArr.length > this.TELEMETRY_MAX_PER_NODE) {\n              newArr = newArr.slice(newArr.length - this.TELEMETRY_MAX_PER_NODE);\n            }\n            // replace the top-level telemetry object with a new reference\n            this.telemetry = {\n              ...this.telemetry,\n              [nodeId]: newArr\n            };\n            // update node summary object (replace nodes reference)\n            const nodeSummary = {\n              lastSeen: payload.lastSeen ?? sample.ts ?? new Date().toISOString(),\n              lastRssi: sample.rssi,\n              channelBusy: sample.busy,\n              clients: payload.sampleCount ?? this.nodes[nodeId]?.clients ?? null,\n              currentChannel: payload.channel ?? this.nodes[nodeId]?.currentChannel ?? null\n            };\n            this.nodes = {\n              ...this.nodes,\n              [nodeId]: {\n                ...(this.nodes[nodeId] || {}),\n                ...nodeSummary\n              }\n            };\n            // logs (prepend, cap and replace reference)\n            const newLog = `feature_update ${nodeId} @ ${sample.ts}`;\n            this.logs = [newLog, ...this.logs].slice(0, this.LOGS_MAX);\n            console.log('[AppComponent] feature_update', nodeId, 'telemetry length=', this.telemetry[nodeId].length);\n          }\n          // --- FORECAST updates ---\n          else if (type === 'forecast_update') {\n            const nodeId = payload.nodeId;\n            if (!nodeId) return;\n            // store forecast object - replace forecasts reference\n            this.forecasts = {\n              ...this.forecasts,\n              [nodeId]: payload\n            };\n            // optionally add a small synthetic telemetry sample so telemetry chart can show something\n            const forecastSample = {\n              ts: payload.timestamp || new Date().toISOString(),\n              busy: payload.forecastBusyPercent ?? null,\n              rssi: null,\n              txBytes: null,\n              __forecast: true\n            };\n            const prevArr = this.telemetry[nodeId] || [];\n            let newArr = [...prevArr, forecastSample];\n            if (newArr.length > this.TELEMETRY_MAX_PER_NODE) {\n              newArr = newArr.slice(newArr.length - this.TELEMETRY_MAX_PER_NODE);\n            }\n            this.telemetry = {\n              ...this.telemetry,\n              [nodeId]: newArr\n            };\n            // logs\n            const newLog = `forecast_update ${nodeId} (${payload.forecastBusyPercent})`;\n            this.logs = [newLog, ...this.logs].slice(0, this.LOGS_MAX);\n            console.log('[AppComponent] forecast_update', nodeId);\n          }\n          // --- OPTIMIZER PLAN ---\n          else if (type === 'optimizer_plan' || type === 'optimizerplan' || type === 'optimizer_plan_v1') {\n            const nodeId = payload.nodeId ?? payload.node;\n            const planItem = {\n              ...payload,\n              status: 'pending',\n              ts: new Date().toISOString()\n            };\n            this.plans = [planItem, ...this.plans].slice(0, this.PLANS_MAX);\n            // reflect suggested channel in nodes summary\n            if (nodeId) {\n              this.nodes = {\n                ...this.nodes,\n                [nodeId]: {\n                  ...(this.nodes[nodeId] || {}),\n                  suggestedChannel: payload.channel\n                }\n              };\n            }\n            this.logs = [`optimizer_plan ${nodeId ?? 'unknown'}`, ...this.logs].slice(0, this.LOGS_MAX);\n            console.log('[AppComponent] optimizer_plan', nodeId, 'plan count=', this.plans.length);\n          }\n          // --- COMMAND STATUS ---\n          else if (type === 'command_status') {\n            const nodeId = payload.nodeId ?? payload.target;\n            const item = {\n              ...payload,\n              ts: new Date().toISOString()\n            };\n            this.commands = [item, ...this.commands].slice(0, this.COMMANDS_MAX);\n            // optionally update nodes state if status indicates applied\n            if (nodeId && payload.command === 'SET_CHANNEL' && payload.payload != null) {\n              const prev = this.nodes[nodeId] || {};\n              this.nodes = {\n                ...this.nodes,\n                [nodeId]: {\n                  ...prev,\n                  currentChannel: Number(payload.payload)\n                }\n              };\n            }\n            this.logs = [`command_status ${nodeId} ${payload.command}`, ...this.logs].slice(0, this.LOGS_MAX);\n            console.log('[AppComponent] command_status', nodeId, 'commands=', this.commands.length);\n          }\n          // --- unknown type (just log) ---\n          else {\n            console.warn('[AppComponent] unknown message type', type);\n            this.logs = [`unknown ${type}`, ...this.logs].slice(0, this.LOGS_MAX);\n          }\n        } catch (e) {\n          console.error('[AppComponent] message handler error', e);\n        }\n      });\n      // open websocket\n      this.ws.connect();\n    }\n    ngOnDestroy() {\n      if (this.sub) this.sub.unsubscribe();\n      this.ws.disconnect();\n    }\n    // Manual command posted by UI\n    sendManualCommand(nodeId, channel) {\n      const body = {\n        nodeId,\n        command: 'SET_CHANNEL',\n        payload: String(channel),\n        triggeredBy: 'manual'\n      };\n      this.http.post('/api/controller/commands', body).subscribe({\n        next: () => {\n          this.logs = [`Manual command sent ${nodeId}->${channel}`, ...this.logs].slice(0, this.LOGS_MAX);\n        },\n        error: err => {\n          this.logs = [`Manual command failed ${nodeId}->${channel}`, ...this.logs].slice(0, this.LOGS_MAX);\n          console.error('[AppComponent] manual command error', err);\n        }\n      });\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function AppComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AppComponent)(i0.ɵɵdirectiveInject(i1.WebsocketService), i0.ɵɵdirectiveInject(i2.HttpClient));\n    }, this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: AppComponent,\n      selectors: [[\"app-root\"]],\n      decls: 36,\n      vars: 7,\n      consts: [[1, \"app-shell\"], [1, \"app-header\"], [2, \"margin\", \"0\", \"font-size\", \"16px\"], [1, \"app-body\"], [1, \"app-grid\"], [1, \"card\"], [3, \"sendCommand\", \"nodes\"], [3, \"telemetry\"], [2, \"height\", \"12px\"], [3, \"forecasts\"], [3, \"plans\"], [3, \"commands\"], [3, \"send\"], [1, \"card\", \"logs\"], [2, \"font-weight\", \"600\", \"margin-bottom\", \"6px\"], [1, \"content-scroll\"], [4, \"ngFor\", \"ngForOf\"]],\n      template: function AppComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵdomElementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"h3\", 2);\n          i0.ɵɵtext(3, \"WMN Telemetry Control Panel\");\n          i0.ɵɵdomElementEnd()();\n          i0.ɵɵdomElementStart(4, \"div\", 3)(5, \"div\", 4)(6, \"div\")(7, \"div\", 5)(8, \"app-node-list\", 6);\n          i0.ɵɵdomListener(\"sendCommand\", function AppComponent_Template_app_node_list_sendCommand_8_listener($event) {\n            return ctx.sendManualCommand($event.nodeId, $event.channel);\n          });\n          i0.ɵɵdomElementEnd()()();\n          i0.ɵɵdomElementStart(9, \"div\")(10, \"div\", 5);\n          i0.ɵɵdomElement(11, \"app-telemetry-chart\", 7);\n          i0.ɵɵdomElementEnd();\n          i0.ɵɵdomElement(12, \"div\", 8);\n          i0.ɵɵdomElementStart(13, \"div\", 5);\n          i0.ɵɵdomElement(14, \"app-forecast-chart\", 9);\n          i0.ɵɵdomElementEnd();\n          i0.ɵɵdomElement(15, \"div\", 8);\n          i0.ɵɵdomElementStart(16, \"div\", 5);\n          i0.ɵɵdomElement(17, \"app-plan-view\", 10);\n          i0.ɵɵdomElementEnd()();\n          i0.ɵɵdomElementStart(18, \"div\")(19, \"div\", 5);\n          i0.ɵɵdomElement(20, \"app-command-history\", 11);\n          i0.ɵɵdomElementEnd();\n          i0.ɵɵdomElement(21, \"div\", 8);\n          i0.ɵɵdomElementStart(22, \"div\", 5)(23, \"app-admin-panel\", 12);\n          i0.ɵɵdomListener(\"send\", function AppComponent_Template_app_admin_panel_send_23_listener($event) {\n            return ctx.sendManualCommand($event.nodeId, $event.channel);\n          });\n          i0.ɵɵdomElementEnd()();\n          i0.ɵɵdomElement(24, \"div\", 8);\n          i0.ɵɵdomElementStart(25, \"div\", 5);\n          i0.ɵɵdomElement(26, \"app-alerts\", 7);\n          i0.ɵɵdomElementEnd();\n          i0.ɵɵdomElement(27, \"div\", 8);\n          i0.ɵɵdomElementStart(28, \"div\", 5);\n          i0.ɵɵdomElement(29, \"app-observability\");\n          i0.ɵɵdomElementEnd();\n          i0.ɵɵdomElement(30, \"div\", 8);\n          i0.ɵɵdomElementStart(31, \"div\", 13)(32, \"div\", 14);\n          i0.ɵɵtext(33, \"Logs\");\n          i0.ɵɵdomElementEnd();\n          i0.ɵɵdomElementStart(34, \"div\", 15);\n          i0.ɵɵdomTemplate(35, AppComponent_div_35_Template, 2, 1, \"div\", 16);\n          i0.ɵɵdomElementEnd()()()()()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(8);\n          i0.ɵɵdomProperty(\"nodes\", ctx.nodes);\n          i0.ɵɵadvance(3);\n          i0.ɵɵdomProperty(\"telemetry\", ctx.telemetry);\n          i0.ɵɵadvance(3);\n          i0.ɵɵdomProperty(\"forecasts\", ctx.forecasts);\n          i0.ɵɵadvance(3);\n          i0.ɵɵdomProperty(\"plans\", ctx.plans);\n          i0.ɵɵadvance(3);\n          i0.ɵɵdomProperty(\"commands\", ctx.commands);\n          i0.ɵɵadvance(6);\n          i0.ɵɵdomProperty(\"telemetry\", ctx.telemetry);\n          i0.ɵɵadvance(9);\n          i0.ɵɵdomProperty(\"ngForOf\", ctx.logs);\n        }\n      },\n      styles: [\".header[_ngcontent-%COMP%]{display:flex;align-items:center;gap:12px;padding:12px;background:#071024;color:#e6eef8}.container[_ngcontent-%COMP%]{display:grid;grid-template-columns:320px 1fr 360px;gap:12px;padding:12px}.card[_ngcontent-%COMP%]{background:linear-gradient(180deg,#ffffff05,#ffffff03);border-radius:10px;padding:12px;color:inherit}.left[_ngcontent-%COMP%]{overflow:auto;height:calc(100vh - 120px)}.center[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:12px}.right[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:12px;overflow:auto;height:calc(100vh - 120px)}.log[_ngcontent-%COMP%]{height:160px;overflow:auto;font-family:monospace;font-size:12px}\"]\n    }));\n  }\n  _staticBlock();\n  return AppComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}