{"ast":null,"code":"/* Import child standalone components & pipes so AppComponent template can use them */\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { NodeListComponent } from './components/node-list/node-list.component';\nimport { TelemetryChartComponent } from './components/telemetry-chart/telemetry-chart.component';\nimport { ForecastChartComponent } from './components/forecast-chart/forecast-chart.component';\nimport { PlanViewComponent } from './components/plan-view/plan-view.component';\nimport { CommandHistoryComponent } from './components/command-history/command-history.component';\nimport { AdminPanelComponent } from './components/admin-panel/admin-panel.component';\nimport { AlertsComponent } from './components/alerts/alerts.component';\nimport { ObservabilityComponent } from './components/observability/observability.component';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./services/websocket.service\";\nimport * as i2 from \"@angular/common/http\";\nimport * as i3 from \"@angular/common\";\nfunction AppComponent_div_35_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const l_r1 = ctx.$implicit;\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(l_r1);\n  }\n}\nexport let AppComponent = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class AppComponent {\n    constructor(ws, http) {\n      this.ws = ws;\n      this.http = http;\n      // Application state (these are mutated in-place to work with DoCheck children)\n      this.nodes = {};\n      this.telemetry = {};\n      this.forecasts = {};\n      this.plans = [];\n      this.commands = [];\n      this.logs = [];\n      // expose Object for templates that use it\n      this.Object = Object;\n      // caps to avoid unbounded growth (adjust as needed)\n      this.TELEMETRY_MAX_PER_NODE = 500;\n      this.PLANS_MAX = 200;\n      this.COMMANDS_MAX = 200;\n      this.LOGS_MAX = 300;\n    }\n    ngOnInit() {\n      this.sub = this.ws.messages$.subscribe(msg => {\n        try {\n          const {\n            type,\n            payload\n          } = msg;\n          if (!type || !payload) return;\n          if (type === 'feature_update') {\n            const nodeId = payload.nodeId;\n            if (!nodeId) return;\n            // keep telemetry arrays per-node, mutated in-place (DoCheck children detect it)\n            this.telemetry[nodeId] = this.telemetry[nodeId] || [];\n            this.telemetry[nodeId].push({\n              ts: payload.windowEnd || new Date().toISOString(),\n              busy: payload.avgChannelBusyPercent ?? payload.busy ?? null,\n              rssi: payload.avgRssi ?? payload.rssi ?? null,\n              txBytes: payload.sumTxBytes ?? payload.txBytes ?? null\n            });\n            // cap\n            if (this.telemetry[nodeId].length > this.TELEMETRY_MAX_PER_NODE) {\n              this.telemetry[nodeId].splice(0, this.telemetry[nodeId].length - this.TELEMETRY_MAX_PER_NODE);\n            }\n            // update node summary object in-place (so NodeList component sees updated props via DoCheck or change detection)\n            this.nodes[nodeId] = {\n              ...(this.nodes[nodeId] || {}),\n              lastSeen: payload.lastSeen ?? new Date().toISOString(),\n              lastRssi: payload.avgRssi ?? payload.rssi ?? this.nodes[nodeId]?.lastRssi,\n              channelBusy: payload.avgChannelBusyPercent ?? this.nodes[nodeId]?.channelBusy,\n              clients: payload.sampleCount ?? this.nodes[nodeId]?.clients,\n              currentChannel: payload.channel ?? this.nodes[nodeId]?.currentChannel\n            };\n            // logs (unshift, capped)\n            this.logs.unshift(`feature_update ${nodeId} @ ${this.telemetry[nodeId].slice(-1)[0].ts}`);\n            if (this.logs.length > this.LOGS_MAX) this.logs.splice(this.LOGS_MAX);\n            // debug trace\n            console.log('[AppComponent] feature_update', nodeId);\n          } else if (type === 'forecast_update') {\n            const nodeId = payload.nodeId;\n            if (!nodeId) return;\n            // Replace forecasts object reference so ngOnChanges in children will run\n            this.forecasts = {\n              ...this.forecasts,\n              [nodeId]: payload\n            };\n            // Keep telemetry synthetic sample (we can keep in-place or replace — keep in-place for charts)\n            this.telemetry[nodeId] = this.telemetry[nodeId] || [];\n            this.telemetry[nodeId].push({\n              ts: payload.timestamp || new Date().toISOString(),\n              busy: payload.forecastBusyPercent ?? null,\n              rssi: null,\n              txBytes: null,\n              __forecast: true\n            });\n            if (this.telemetry[nodeId].length > this.TELEMETRY_MAX_PER_NODE) {\n              this.telemetry[nodeId].splice(0, this.telemetry[nodeId].length - this.TELEMETRY_MAX_PER_NODE);\n            }\n            // logs (replace reference so any UI bound to logs updates)\n            this.logs = [`forecast_update ${nodeId}`, ...this.logs].slice(0, this.LOGS_MAX);\n            console.log('[AppComponent] forecast_update -> forecasts keys=', Object.keys(this.forecasts));\n          } else if (type === 'optimizer_plan') {\n            // append plan (mutate plans array)\n            this.plans.unshift({\n              ...payload,\n              status: 'pending',\n              ts: new Date().toISOString()\n            });\n            if (this.plans.length > this.PLANS_MAX) this.plans.splice(this.PLANS_MAX);\n            // also reflect suggested channel in nodes summary object\n            if (payload.nodeId) {\n              this.nodes[payload.nodeId] = {\n                ...(this.nodes[payload.nodeId] || {}),\n                suggestedChannel: payload.channel\n              };\n            }\n            this.logs.unshift(`optimizer_plan ${payload.nodeId ?? 'unknown'}`);\n            if (this.logs.length > this.LOGS_MAX) this.logs.splice(this.LOGS_MAX);\n            console.log('[AppComponent] optimizer_plan', payload.nodeId);\n          } else if (type === 'command_status') {\n            // append command status\n            this.commands.unshift({\n              ...payload,\n              ts: new Date().toISOString()\n            });\n            if (this.commands.length > this.COMMANDS_MAX) this.commands.splice(this.COMMANDS_MAX);\n            // update node currentChannel if command applied\n            if (payload.nodeId && payload.command === 'SET_CHANNEL' && payload.payload != null) {\n              this.nodes[payload.nodeId] = {\n                ...(this.nodes[payload.nodeId] || {}),\n                currentChannel: Number(payload.payload)\n              };\n            }\n            this.logs.unshift(`command_status ${payload.nodeId ?? 'unknown'} ${payload.command ?? ''}`);\n            if (this.logs.length > this.LOGS_MAX) this.logs.splice(this.LOGS_MAX);\n            console.log('[AppComponent] command_status', payload.nodeId);\n          } else {\n            // unknown type\n            this.logs.unshift(`unknown message ${type}`);\n            if (this.logs.length > this.LOGS_MAX) this.logs.splice(this.LOGS_MAX);\n            console.warn('[AppComponent] unknown message type', type);\n          }\n        } catch (err) {\n          console.error('[AppComponent] message handler error', err);\n        }\n      });\n      // connect websocket (service handles activation)\n      this.ws.connect();\n    }\n    ngOnDestroy() {\n      if (this.sub) this.sub.unsubscribe();\n      this.ws.disconnect();\n    }\n    // manual command via UI\n    sendManualCommand(nodeId, channel) {\n      const body = {\n        nodeId,\n        command: 'SET_CHANNEL',\n        payload: String(channel),\n        triggeredBy: 'manual'\n      };\n      this.http.post('/api/controller/commands', body).subscribe({\n        next: () => {\n          this.logs.unshift(`Manual command sent ${nodeId}->${channel}`);\n          if (this.logs.length > this.LOGS_MAX) this.logs.splice(this.LOGS_MAX);\n        },\n        error: err => {\n          this.logs.unshift(`Manual command failed ${nodeId}->${channel}`);\n          if (this.logs.length > this.LOGS_MAX) this.logs.splice(this.LOGS_MAX);\n          console.error('[AppComponent] manual command error', err);\n        }\n      });\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function AppComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AppComponent)(i0.ɵɵdirectiveInject(i1.WebsocketService), i0.ɵɵdirectiveInject(i2.HttpClient));\n    }, this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: AppComponent,\n      selectors: [[\"app-root\"]],\n      decls: 36,\n      vars: 7,\n      consts: [[1, \"app-shell\"], [1, \"app-header\"], [2, \"margin\", \"0\", \"font-size\", \"16px\"], [1, \"app-body\"], [1, \"app-grid\"], [1, \"card\"], [3, \"sendCommand\", \"nodes\"], [3, \"telemetry\"], [2, \"height\", \"12px\"], [3, \"forecasts\"], [3, \"plans\"], [3, \"commands\"], [3, \"send\"], [1, \"card\", \"logs\"], [2, \"font-weight\", \"600\", \"margin-bottom\", \"6px\"], [1, \"content-scroll\"], [4, \"ngFor\", \"ngForOf\"]],\n      template: function AppComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"h3\", 2);\n          i0.ɵɵtext(3, \"WMN Telemetry Control Panel\");\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelementStart(4, \"div\", 3)(5, \"div\", 4)(6, \"div\")(7, \"div\", 5)(8, \"app-node-list\", 6);\n          i0.ɵɵlistener(\"sendCommand\", function AppComponent_Template_app_node_list_sendCommand_8_listener($event) {\n            return ctx.sendManualCommand($event.nodeId, $event.channel);\n          });\n          i0.ɵɵelementEnd()()();\n          i0.ɵɵelementStart(9, \"div\")(10, \"div\", 5);\n          i0.ɵɵelement(11, \"app-telemetry-chart\", 7);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(12, \"div\", 8);\n          i0.ɵɵelementStart(13, \"div\", 5);\n          i0.ɵɵelement(14, \"app-forecast-chart\", 9);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(15, \"div\", 8);\n          i0.ɵɵelementStart(16, \"div\", 5);\n          i0.ɵɵelement(17, \"app-plan-view\", 10);\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelementStart(18, \"div\")(19, \"div\", 5);\n          i0.ɵɵelement(20, \"app-command-history\", 11);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(21, \"div\", 8);\n          i0.ɵɵelementStart(22, \"div\", 5)(23, \"app-admin-panel\", 12);\n          i0.ɵɵlistener(\"send\", function AppComponent_Template_app_admin_panel_send_23_listener($event) {\n            return ctx.sendManualCommand($event.nodeId, $event.channel);\n          });\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelement(24, \"div\", 8);\n          i0.ɵɵelementStart(25, \"div\", 5);\n          i0.ɵɵelement(26, \"app-alerts\", 7);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(27, \"div\", 8);\n          i0.ɵɵelementStart(28, \"div\", 5);\n          i0.ɵɵelement(29, \"app-observability\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(30, \"div\", 8);\n          i0.ɵɵelementStart(31, \"div\", 13)(32, \"div\", 14);\n          i0.ɵɵtext(33, \"Logs\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(34, \"div\", 15);\n          i0.ɵɵtemplate(35, AppComponent_div_35_Template, 2, 1, \"div\", 16);\n          i0.ɵɵelementEnd()()()()()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(8);\n          i0.ɵɵproperty(\"nodes\", ctx.nodes);\n          i0.ɵɵadvance(3);\n          i0.ɵɵproperty(\"telemetry\", ctx.telemetry);\n          i0.ɵɵadvance(3);\n          i0.ɵɵproperty(\"forecasts\", ctx.forecasts);\n          i0.ɵɵadvance(3);\n          i0.ɵɵproperty(\"plans\", ctx.plans);\n          i0.ɵɵadvance(3);\n          i0.ɵɵproperty(\"commands\", ctx.commands);\n          i0.ɵɵadvance(6);\n          i0.ɵɵproperty(\"telemetry\", ctx.telemetry);\n          i0.ɵɵadvance(9);\n          i0.ɵɵproperty(\"ngForOf\", ctx.logs);\n        }\n      },\n      dependencies: [CommonModule, i3.NgForOf, FormsModule, NodeListComponent, TelemetryChartComponent, ForecastChartComponent, PlanViewComponent, CommandHistoryComponent, AdminPanelComponent, AlertsComponent, ObservabilityComponent],\n      styles: [\".header[_ngcontent-%COMP%]{display:flex;align-items:center;gap:12px;padding:12px;background:#071024;color:#e6eef8}.container[_ngcontent-%COMP%]{display:grid;grid-template-columns:320px 1fr 360px;gap:12px;padding:12px}.card[_ngcontent-%COMP%]{background:linear-gradient(180deg,#ffffff05,#ffffff03);border-radius:10px;padding:12px;color:inherit}.left[_ngcontent-%COMP%]{overflow:auto;height:calc(100vh - 120px)}.center[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:12px}.right[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:12px;overflow:auto;height:calc(100vh - 120px)}.log[_ngcontent-%COMP%]{height:160px;overflow:auto;font-family:monospace;font-size:12px}\"]\n    }));\n  }\n  _staticBlock();\n  return AppComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}